Where: https://youtu.be/CH4nsqgrqzI?feature=shared

Wen: Today, November 2, 6PM UTC  (you can watch anytime after the premiere)

This lecture will introd uce common vulnerability issues in Solana programs, how they can be exploited and most importantly how you can avoid them.
Useful links:
https://www.anchor-lang.com/docs/security-exploits
https://www.soldev.app/course (Module 5 - Solana Program Security)

We have been considering adding a security task, but:

1. A task with a/b/c/d question structure would not be valuable, as you need hands-on experience with security, not just answering theoretical questions.
2. You should watch a security lecture and apply those tips within your final dApp. (To compensate for the task, if we find a critical vulnerability in your dApp - instant 0 points for the final task, <= Joke, of course! :D, however try to do your apps as secure as possible)
3. We are exhausted from Breakpoint shipping the best content.

Of course, if you have literally ANY question regarding the security, feel free to DM us !
Of course, we are still here to help you with your dApps and implementations, so feel free to DM us !

# 文字起こし
```
0:02
hello everyone and welcome to the next lesson of school of Solana with ay blockchain it's Adam here and today we
0:10
will be talking about Security in Solana programs so yeah let's jump straight
0:19
in so first of all I would like to start with the motivation and why should you
0:24
care actually about the security so as you all know there is a lot of money in
0:30
crypto space and actually in uh 2022 there was over 4 billion dollars
0:39
that were lost in the crypto space overall um and uh there was roughly over
0:46
500 million stolen on Solana ecosystem only so I have done a little research
0:53
here and uh I found the biggest um exploits on Solana last year so so uh
1:01
maybe you might know so there is a wormhole so actually it's one of the biggest uh ever uh where approximately
1:10
$338 million were stolen lost uh then there is a Casio $ 52 million Crea
1:20
Finance 8 million um and also I have included here mango Market uh where
1:26
approximately $16 million uh uh in the time of exploit uh were uh
1:34
were lost so yeah I have included also mango markets uh although some someone might
1:41
say that it wasn't a buck it was a feature of the protocol but uh never mind you know it it was an um exploit of
1:49
the platform uh so yeah I think it's obvious why everybody should care about the the
1:57
security uh because yeah there is a lot of money in in the crypto space so uh we
2:03
must secure the the funds as much as we can so here I have some basic security
2:11
tips for you uh before uh we will start uh with the actual uh exploits and the
2:19
first tip is use anchor in most in most cases um why you should do that so
2:27
actually it saves you a lot of boilerplate code uh in the first hand so
2:34
you can basically focus on the business logic of your program and uh you don't
2:39
have to you know care so much about um the uh correctly implementing all the
2:47
checks and uh I have included here a little example on the right side so U
2:53
here this is um very short code on 35 lines
3:00
uh which is written in Anchor so in Anchor uh it's really short and the
3:07
instruction has you know only one line um whereas uh there is the context
3:15
that contains most of the um Security checks um and uh yeah so the the code is
3:24
very very clean and uh easy to understand uh whereas if you use cargo
3:30
expand command so you can try it um by yourself also on on your programs so you
3:36
will see what anchor actually generates um and what kind of checks are there and
3:42
so this code um after some formatting you know uh uh expands to roughly 800
3:51
lines so there are not only uh Security checks of course there there is some
3:56
other boiler plate uh generated by anchor uh but it gives you an idea uh
4:02
what actually uh anchor does for you um yeah so this is one reason and
4:11
also anchor it um it became actually kind of standard in uh in Solana uh so
4:19
it will be easier for everyone to review your code um if it's uh your colleagues
4:27
or maybe some Auditors um um I would recommend you to use anchor so of course
4:32
there are some situations where you might use raw
4:38
Solana uh no doubt but uh yeah especially if you are a beginner um I
4:44
highly recommend you to use anchor next tips text uh test
4:53
extensively so yeah it is um a problem in uh crypto space is that uh you know
5:00
the projects uh would like to deploy their uh projects um very quickly uh so
5:07
the focus on testing uh is not so high uh however I would recommend you to to
5:14
test extensively uh and not only the the happy path scenarios but yeah Focus also
5:21
on unhappy path scenarios um and uh there is the common saying uh think like a hacker so um
5:31
um you should really try to uh you know Supply different inputs to your program
5:38
uh some uncommon or unex unexpected uh inputs and so on uh this might really um
5:46
uncover different bugs and security issues in the um in the beginning of your
5:52
project and last but not Le and not least have your project audited so we
5:59
all make mistakes you know um and uh as an
6:04
example uh there is a lot of uh programs directly from Solana foundation so might
6:10
you might think you might think that uh these guys are the best uh in the field
6:16
uh it might be true uh but still they get uh audits so um never trust only
6:23
yourself um get audited um even the Auditors are only human so it's
6:28
recommended to have uh at least two independent Audits and uh um yeah just
6:39
uh just do not TR trust only yourself so yeah these are the basic
6:47
security tips and uh now we can go to the common security
6:54
exploits there is a lot of different kinds of EXP exploits maybe some of them
7:01
could be grouped um together uh because uh they have the same uh
7:09
basis uh I have chosen here uh some of them uh the most important and the most
7:16
common and uh we will go through each of them I will show you some uh examples
7:24
how it might be exploited and uh what is actually the correct solution
7:32
the first one is sign or check so probably you already uh spoke
7:39
about it in the previous lessons it is very important that uh you verify that the right parties have signed a
7:48
transaction here is an example of incorrect or insecure uh
7:54
code this is actually just a anchor context um which is called update user
7:59
data um it is a context of um of an instruction of the same name so imagine
8:07
that uh a user would like to update uh some data on chain and uh here you can see that uh
8:15
one account one input account is the user account and the other one is the
8:20
data account so the data account is bound to the user because uh it is a PDA
8:28
uh address that is based on some seats um the user data and the user
8:36
key however uh here in this case um of the user account uh only account info
8:43
type is used and this type actually uh does not check anything so it is insecure and uh
8:50
actually anyone who knows uh public key of the user can uh call this
8:57
instruction and uh yeah uh he doesn't know uh he doesn't need to know the
9:02
private key to sign it so in that case anyone can basically Supply uh the
9:10
correct user account and uh update the data of any
9:15
user so the correct way to do it with anchor uh instead of using account info
9:21
uh would be to use the signer uh type the signer type uh actually
9:28
automatically uh verifies that the signer or that this user signed the
9:34
transaction and uh therefore in this case um you cannot Supply a different
9:40
user account uh for a given data
9:49
account the next vulnerability is the uh Missing address
9:55
check so in this in that case you you have to verify that an account has the expected
10:01
address so as you know uh you you are already familiar with the Solana
10:08
programming model uh so you know that each program needs uh as inputs all the
10:14
accounts that it will work with so it will uh that it will read or write to uh and uh in yeah maybe not most
10:23
cases but very often you have to verify that the uh supplied accounts are actually the accounts that you expect so
10:31
here is again an example imagine you have a some struct that holds
10:37
configuration data so the first is a public key of an admin that is allowed
10:45
to modify um some some data and the data
10:52
itself again here we have the context of the
10:57
instruction and with two accounts so the first account is the admin account that
11:03
has to sign the instruction so that's correct and the other account is a PDA
11:09
account uh with the config data that is on some um PDA uh address global address
11:17
for for your program so in this case um actually it is
11:23
insecure because the admin account is not bound to the config
11:29
uh to the config account and to the data itself so actually in your program you
11:35
would like to verify that the admin account is the same account that is
11:40
saved in your configuration data and it is not done here so what an eer could
11:46
easily do is to supply any kind of um
11:51
account uh as for admin sign the transaction and then um Supply uh the
11:59
configuration data uh of your program and the program would
12:05
work the correct way to do it is to use uh anchor
12:12
constraint so there are actually different ways how to implement it but
12:17
at least for me the the nicest one is to use the has one
12:23
constraint as here you can see uh we we have here has one admin so
12:31
actually uh here the name admin has to match uh
12:36
the um the data structure so you have here the admin
12:42
name in your config data and it has to match also the name um of the account
12:48
that you supply so it will verify that the admin account is uh actually the
12:54
same or has the same public key uh as it is saved in your configuration
12:59
data that way uh you cannot Supply different uh admin
13:10
account then we have the owner check or the ownership check um it is a little bit similar so
13:20
you have to you have to check uh that uh an
13:25
account that you supplied to your program is owned by by the expected
13:31
program uh here is a scheme so you have your program here that receives as input
13:38
uh some configuration data account for example and uh as you know each account has
13:46
different fields so one of the field is the owner field that holds the public key of the
13:52
of the owner of your account and then you have some data for
13:57
example and if we will take this code again it
14:04
is a uh it is a context of uh withdraw instruction and uh consider following
14:11
scenario so again we have um an admin that signs the instruction for now for
14:19
for the purpose of this uh example just um uh let's suppose that the uh admin uh
14:27
is verified that verified directly in the uh instruction uh so we omitted it here uh
14:35
so we can use the account info uh structure or type uh so yeah let's
14:42
consider that we cannot uh Supply a different uh admin that it is checked
14:48
elsewhere it is possible uh but for some reason uh we
14:53
have decided to uh use an unchecked account info uh type for the config
14:58
configuration uh account and then we have some uh treasury account uh that is
15:04
again a PDA uh so in that case um an eer could
15:10
actually uh create the configuration account uh
15:15
by his program and uh he could basically create
15:21
exactly the same data structure of the config account so when it is passed uh
15:27
in your program uh you will be able to access the config do admin uh. key uh
15:34
property or or function and uh the check that the admin uh and the
15:41
configuration um saved uh in your account are same will
15:46
pass and therefore it will allow him for example to withdraw the fees from the from the
15:52
treasury so yeah this is of course uh insecure and the correct way to do it
15:59
here it's is simply to use the account type so the account type uh actually
16:07
automatically uh checks the owner uh so if you if you leave it um
16:13
just the way it is here on the right side uh that it will uh then anchor will
16:18
uh expect that the owner of this account uh should be your program and uh uh actually uh it will
16:26
check it for you automatically you don't have to do anything uh anything else here um in some cases uh you might want
16:34
that uh the owner is uh some different program for example uh so in that case
16:41
you can use the owner uh constraint but yeah um it's actually
16:50
very easy to to do the uh ownership uh check with anchor um and uh what I want
16:57
to show here here is uh that uh in most cases uh if you have um an account that
17:04
you would like to uh deserialize so a data account uh then you will anyway use
17:11
the account uh type uh because then you have to also Supply uh the uh type uh or
17:17
the structure that you would like to deserialize uh so it's not very likely
17:22
that uh you would use the account info um uh so in that way Anor is uh quite
17:29
intuitive but anyway I wanted to um show you here uh the ownership uh exploit so
17:38
uh you might know that it may happen and uh maybe another remark here
17:45
uh so for the treasury account we actually used account info but um besides the fact that this
17:53
is uh not the data account uh it is just um address that holds the fund
17:59
uh but here is also another uh owner check um that is kind of intrinsic uh in
18:05
the fact that uh the treasury account is on a PDA address and if it if it is a
18:12
PDA address uh as you might already know the PDA address is derived from some
18:18
seats so in this case this is the treasury here uh the bump and also the
18:23
ID or the public key of your program so actually anchor here uh checks that uh
18:31
the address is correct because uh it will calculate and verify for you the uh
18:37
that the PDA address is correctly uh calculated here so this is another way
18:43
how you can check for
18:52
ownership so the next exploit is arbitrary CPI CPI stands
19:01
for cross program invocation so it's a little bit similar to the previous one um in that way that
19:10
uh you have to verify that the target program that we want to invoke has the correct
19:16
address so let's take a following structure of a program uh let's suppose
19:24
that we have a main program and this main program calls an external
19:29
program and also takes us input uh as inputs the user account some pool
19:35
account and also maybe some uh system account I omitted it here for the sake
19:40
of Simplicity and uh yeah so the external program that you would like to call of
19:47
course has some key that actually you have to
19:52
verify uh but yeah before we will uh I I can show you how you can do Do It um I
19:59
can give you an example how you can actually uh exploit the arbitrary
20:05
CPI so imagine the the scenario that you have your main program that for some
20:12
reason calls your external Pro program in order to um transfer the funds from
20:19
the user account uh to the pool account and uh so the main program calls the
20:25
external program and uh once the um external program successfully finishes
20:32
its execution then the main program will lock uh that uh the user for example
20:38
deposited some amount uh to the uh to the pool account and again for some
20:44
reason it's only the external program that verifies uh the correctness of the
20:50
pool account address so the way how you could exploit
20:56
uh exploit exploited is uh that actually anyone uh if you do
21:03
not check the key of your external program and that it is uh the correct program that the main program should
21:10
execute is that you can supply a different program uh that will uh actually uh take
21:19
the signature from the user so the the external program uh due to um
21:26
privilege um uh privilege propagation uh will be
21:32
allowed to transfer the fun fund from the user account so uh it will transfer
21:38
the fund to maybe some other account or it will actually not
21:44
transfer the account the the funds at all uh but uh the supplied malicious
21:50
program will actually uh successfully finish and then your main program uh
21:57
will not notice uh that uh something bad happened and it will loog that um the
22:04
given user actually locked his uh funds in the pool
22:10
account so this is actually something that you don't
22:16
want and uh how actually it might see in your program again if it is if you use
22:23
the account info uh type which is um
22:29
checked and uh yeah the correct way to do it is to use anchors uh program
22:38
type uh the program type uh verifies uh that uh the program which is in this
22:45
that case called my program uh has the correct uh address as you
22:53
expect uh there is a little um remark to that so and actually supports uh out of
23:00
the box only three programs so the first program is System Program if you want to
23:05
create for example new accounts and uh then um token and Associated token uh
23:13
programs so these are the token uh the sorry the programs uh that are used uh
23:18
very often uh that's why um anchor supports them out of the box then of course uh
23:26
you can use an uh to um uh to uh
23:33
basically um generate for you the CPI uh modules
23:40
automatically um it is uh out of scope of this lesson uh but uh yeah it's quite
23:46
easy so I would recommend you to check uh the uh cross program
23:52
invocations uh chapter in uh the uh anchors uh documentation
23:59
yeah but once you you do that uh then the verification uh of your um exter
24:06
program is really very easy uh you can only use the program uh type and the
24:11
name of your of your program and uh then again Anor does the checks for
24:22
you then we have the math and logical issues so this chap is very important
24:30
because in this case anchor actually um cannot really help you it can help you
24:37
to some extent uh but actually anchor doesn't know anything about your logic
24:44
about your program uh so anchor can only do what you um tell it to do uh so the
24:51
math and logic issues you have to uh take care of them uh by yourself
24:58
one of them or the the most common is um of course uh the or are the problems
25:06
with arithmetics and precision issues so very often it happens that you have some
25:12
kind of overflow or underflow so you should uh always use or maybe not always
25:18
but in most cases you should use the checked uh arithmetics uh in
25:24
Rust and uh you should uh um verify your
25:30
um your calculations so yeah that's why also at
25:36
the very beginning I told you that it is uh very important to uh test extensively
25:42
your programs um because such kind of issues
25:48
uh can be uh effectively discovered uh within the the tests uh at the uh at the
25:55
beginning or before the the deployment if you have the tests then you should validate the
26:03
account data and the instruction parameters so again anchor can help you
26:09
to deserialize the the account data for example uh it will help you uh to to
26:15
check that uh somebody didn't uh Supply uh for example um uh incorrect uh
26:24
accounts with uh the same uh structure uh then rust uh can help you to verify
26:32
that the supplied uh parameters uh to the in instructions have actually
26:38
correct types and so on but Anor and rust uh again do not
26:44
know what you would like to do uh with this uh data and uh with the values so
26:51
it's entirely on yourself to verify that the values that are supplied to your
26:57
program uh are correct and that they are for example within uh the correct range and
27:03
so on the next Point here is that you
27:09
should make sure that the instructions are executed in correct order so sometimes um it might be quite
27:20
logical that uh for example in the case uh of uh of a voting program
27:28
uh that you would like to wait um for uh the
27:33
voting uh before the voting actually starts so uh let's imagine you have some
27:39
starting date uh so of course you would like to receive uh the votes um after
27:45
the starting dates so it's kind of logical uh for that uh common practice
27:51
is that you keep some kind of uh internal State um in your program and
27:57
you just uh check uh that your program is in uh is in the correct state in some
28:05
cases uh it might not be so obvious uh so there might
28:11
be different uh scenarios uh where uh uh
28:16
you will for example set some data in one instruction uh that uh will be used
28:22
and in another another instruction so again in that case
28:28
uh you have to uh prevent the the bugs uh by testing for example the different
28:35
uh different order of uh of the
28:41
instructions and then the uh the the last um very common problem that I uh
28:47
would like to share with you is that you should also prevent uh unintended
28:52
behavior when you pass uh duplicate uh mutable accounts actually actually um or
29:00
yeah um the accounts do not have to be uh mutable uh but uh yeah um very often
29:10
uh you want to have for example user uh user a and uh user B and there is some
29:16
action uh that happens uh but you don't think about the
29:22
situation if somebody will supply the same account for the user a and user B
29:29
uh so this is something that you should um have in mind and again uh the best
29:35
thing is uh to uh do uh the proper testing uh for that uh but uh yeah the
29:43
way how you can pre uh prevent it uh is for example using the anchor
29:48
constraints um and uh you can have something like this that the user a key
29:55
uh is uh not equal uh to the user b key
30:00
uh that way you can keep the check or the security check within the uh the
30:06
context and you don't have to mix it with your with your
30:14
logic next in the line are the reinitialization and Revival adexs so
30:21
they are kind of related um because uh they are related both to the lifetime of
30:29
uh the account in the first case of reinitialization um it's that you
30:37
actually in most cases don't want to reinitialize an already initialized
30:42
account um because um a new initialization might reset for example
30:48
some internal State um and it would give the opportunity to an attacker to
30:54
exploit your program um to prevent that uh in Anchor
31:00
uh it's quite easy so you can just use the init constraint on an account and uh what
31:08
actually anchor does is that it um adds um
31:14
discriminator uh to to a data account a discriminator it is um array of eight
31:21
bytes at the beginning of the data uh that are basically related to the data
31:28
uh structure uh that you saved in the in the data account and uh the init
31:35
constraint um actually checks that uh the discriminant uh was checked or not
31:42
uh sorry was set or not and uh it is if it has been set previously uh then uh it
31:50
will not reinitialize the given account then the other situation is the
31:58
Revival attack uh so it's similar uh because you actually do not want to
32:03
reuse an already closed account uh to close an account on salana
32:10
uh you have to set its lamp port to zero and uh therefore the account uh will not
32:18
be rent exempt anymore and it will be garbage garbage collected by the
32:25
runtime however the garbage collection actually runs only after the transaction
32:32
is finished and therefore if the account is not closed properly uh a neter can
32:40
close an account in one instruction and then includeed directly a new
32:46
instruction to reinitialize uh the account or he can for example send uh
32:52
new lamp ports to the account and that way uh the um uh the account uh will not
33:00
be garbage collected again in Anchor you can use the close
33:07
constraint and you can or you have to include the receiver uh account that
33:13
will receive the uh rent Lamport and uh the close constraint
33:21
actually um resets or sets uh the discrimination
33:28
uh to a new value that is specific to a closed account and that way uh you
33:33
cannot uh basically um reuse the already closed
33:42
account and then I have also included some other issues uh so we don't have uh
33:48
a lot of time so we cannot uh cover all the possible issues within the time
33:54
frame uh that we have but um I wanted to mention them anyway so that you know
34:00
that it exists first of them is that uh you should verify the account data type to
34:07
avoid so-called tape type cosplay uh it means that um an eer could
34:16
um eventually uh Supply um a data uh
34:21
with different data type and then your program uh would distalize it uh
34:27
with yeah uh the the given data type that does not correspond and uh yeah as the DAT data
34:35
types might overlap for example um it might still be um be serialized uh
34:44
correctly but uh yeah with uh um incorrect
34:50
data uh and it might give the theer uh a possibility to exploit your program
34:57
uh in Anchor uh this is very easy um you can only uh use the account type uh with
35:05
your given uh type uh and uh then aner
35:10
uh checks the discriminator uh at the beginning of your of your data uh to match uh the the
35:17
data types then the next point is that you
35:23
should um always use the canonical bump to avoid multiple valid
35:28
pdas uh canonical bump means that uh this is the very first value of a uh
35:35
bump uh that you calculate when you calculate the PDA uh address because uh
35:42
PDA address um as you might know it's a special address that is soal bumped of
35:51
the um curve and uh there it doesn't have a
35:58
private key uh but there might be different uh values of the bump so uh
36:04
there is um yeah best practice that only the canonical so that means the first or
36:10
the the highest uh bump number uh should be
36:15
used to to avoid um having multiple valid
36:21
pdaas and the way how you can do it is that um yeah you should basically use
36:27
anchor in the standard way that you will uh either leave the bump here uh empty
36:35
so therefore um anchor will calculate it for for you and anchor takes every time
36:42
the canonical bump or uh you can as you can see here uh you can uh use the bump
36:52
that you have stored previously during the initialization so here uh the data.
36:57
bump refers to a bump value that is actually saved in your data account but
37:04
you should never uh let the user to choose an arbitrary
37:11
bump and the last Point here is that uh you should not use shared or Global PDA
37:20
authorities um instead you should use um yeah specific or user specific pdas so
37:29
here in that example you can see that you have two accounts one data account
37:35
uh and the user account and uh as you can see here uh
37:40
the data account is related to the user account uh because the seats are derived
37:49
from the users uh public Key address uh so you should never uh have a
37:57
global PDA account that gives uh Authority uh to yeah a deal with uh data
38:07
from other users of course there might be or there are some use cases but uh um
38:16
general practice is to uh avoid
38:24
this and uh yeah a lot a lot last but not least I have here uh for you a
38:30
recommended resource uh it is actually um a lesson uh from Solana itself uh
38:38
here is the the address Sol def. app course and if you will scroll uh to the
38:46
bottom of the page there is a last module 7 uh on the um program security
38:54
uh I highly recommend you to go uh through um through these lessons uh it's
39:00
quite extensive there are different uh examples um there are also uh different
39:07
uh demos um it has been inspired by um
39:13
the uh examples from uh Armani uh who
39:19
developed um anchor so yeah I can highly recommend it if you are interested in
39:25
more in more details so that's it for for the common
39:33
exploits maybe at at the very end I would like to do a short wrap
39:39
up uh again I have repeated here the tips that I uh showed you at the very
39:46
beginning that um I recommend you to use anchor and it's built in security
39:53
features it has uh um really um nice
39:59
advantages uh as I explained before you should text test extensively your your
40:06
programs uh and have your project um audited uh as I said before so everybody
40:15
uh makes uh mistakes uh and uh yeah it is uh again uh usual practice to uh
40:24
audit your uh your projects and maybe some uh other uh tips
40:30
that you should uh avoid non-standard code and libraries uh so I believe that
40:36
if you will follow uh the the common practice and that uh if you will follow
40:44
the guidelines from uh anchor uh then you can avoid a lot of
40:49
bugs uh that are Solana specific uh and uh then you can actually Focus on on the
40:57
logic and test test the logic of your program um another tip is that uh you
41:05
should compare the list of common exploits uh with your uh program
41:10
regularly so um you know it's very easy to to
41:15
forget uh about something or very often you modify multiple times your program
41:22
so maybe at the very beginning uh you um thought about different scenarios but
41:29
after some modifications um you um integrated some
41:35
uh some Buck without knowing it so I recommend you to go quite often through
41:42
the list of common exploits and uh compare it with your
41:48
program and uh the very last point is that I have shown you different um
41:56
possibilities of exploits um but uh very often in practice uh the exploits might
42:05
be um a combination of multiple uh issues that you have so it doesn't have
42:11
to be uh only one of them uh but uh because you actually uh have two uh
42:20
different issues uh it might give the possibility to the exploiter uh to uh to
42:28
with your your funds for example or something like that so uh as a separate issues maybe uh it is not critical but
42:37
um you should uh all the time consider more complex
42:44
scenarios yeah so that's it for today I hope that you have learned something and
42:50
thank you very much and see you next time

0:02
大家好，欢迎来到 Solana 学校的下一课，我是区块链，我是 Adam，今天我们
0:10
将讨论 Solana 程序中的安全性，所以我们直接跳吧
0:19
首先我想从动机以及为什么你应该开始
0:24
实际上关心安全，所以你们都知道里面有很多钱
0:30
加密货币领域，实际上到 2022 年，这个数字就超过了 40 亿美元
0:39
总体而言，在加密货币空间中丢失了，嗯，呃，大致结束了
0:46
仅在 Solana 生态系统上就被盗了 5 亿，所以我做了一些研究
0:53
在这里，呃，我去年发现了 Solana 上最大的漏洞，所以如此呃
1:01
也许你可能知道有一个虫洞，所以实际上它是有史以来最大的虫洞之一，大约在哪里
1:10
3.38亿美元被偷丢了呃然后还有一块卡西欧5200万美元的Crea
1:20
融资800万嗯，我也把这里包括了芒果市场呃在哪里
1:26
漏洞利用期间价值约 1600 万美元
1:34
迷路了所以是的我也包括了芒果市场呃虽然有些人可能
1:41
说这不是一个钱，它是协议的一个功能，但呃没关系，你知道它是一个嗯利用
1:49
这个平台，嗯，是的，我认为很明显为什么每个人都应该关心
1:57
安全呃，因为是的，加密货币领域有很多钱，所以呃我们
2:03
必须尽可能确保资金安全，所以我在这里有一些基本的安全保障
2:11
给你的提示呃，在呃之前我们将从实际的呃漏洞利用开始呃
2:19
第一个技巧是在大多数情况下使用锚点，为什么你应该这样做
2:27
实际上，它可以第一手为您节省大量样板代码，所以
2:34
你基本上可以专注于你的程序的业务逻辑，但是你没有
2:39
你必须知道非常关心呃正确实施所有
2:47
检查，呃，我在右侧添加了一个小例子，所以你
2:53
这是非常短的代码，共 35 行
3:00
呃这是用 Anchor 写的所以在 Anchor uh 中它真的很短而且
3:07
指令让你只知道一行，但是呃有上下文
3:15
包含大部分嗯安全检查嗯和呃是的所以代码是
3:24
非常非常干净，而且很容易理解，而如果你使用货物
3:30
展开命令，这样你就可以在你的程序上自己尝试一下，这样你
3:36
将看到哪个锚实际上生成了 um 以及有哪些类型的检查
3:42
所以这段代码经过一些格式化后你知道呃呃扩展到大约800
3:51
线路所以不仅有呃安全检查当然还有一些
3:56
其他由锚点生成的样板呃但它给了你一个想法呃
4:02
呃锚实际上为你做了什么嗯是的所以这是一个原因
4:11
也锚定它，它实际上成为索拉纳呃的标准
4:19
如果是你的同事的话，每个人都会更容易审查你的代码
4:27
或者也许一些审计员嗯嗯我会推荐你使用锚所以当然
4:32
在某些情况下你可能会使用 raw
4:38
Solana 呃，毫无疑问，但是呃，是的，尤其是如果你是初学者的话，嗯，我
4:44
强烈建议您使用锚下一个提示文本呃测试
4:53
广泛所以是的，嗯，加密空间中的一个问题是，嗯，你知道
5:00
项目呃想要部署他们的呃项目嗯非常快呃所以
5:07
对测试的关注度不是那么高，但是我建议你这样做
5:14
广泛测试呃，不仅是快乐路径场景，而且是的，焦点也
5:21
在不愉快的道路场景中，嗯，有一个常见的说法，嗯，像黑客一样思考，所以嗯
5:31
嗯，你真的应该尝试，呃，你知道，为你的程序提供不同的输入
5:38
呃一些不常见的或 unex 意外的呃输入等等呃这可能真的嗯
5:46
在您的项目开始时发现 um 中的不同错误和安全问题
5:52
项目，最后但并非最不重要的是对您的项目进行审核，以便我们
5:59
所有人都会犯错误，你知道嗯和呃作为一个
6:04
示例呃有很多呃程序直接来自 Solana 基金会所以可能
6:10
你可能会认为这些人是这个领域最好的
6:16
呃，这可能是真的，呃，但他们仍然得到呃审计，所以嗯，永远不要只相信
6:23
你自己嗯接受审计嗯即使审计员也只是人类所以它是
6:28
建议至少进行两次独立审核，嗯嗯，只是
6:39
呃，只是不要只相信自己，所以是的，这些是基本的
6:47
安全提示，呃现在我们可以转到共同安全
6:54
有很多不同类型的 EXP 漏洞利用，也许其中一些
7:01
可以将 um 分组在一起 uh 因为 uh 他们有相同的 uh
7:09
基础呃我在这里选择了呃其中一些呃最重要和最重要的
7:16
常见的，呃，我们将逐一进行介绍，我将向您展示一些呃示例
7:24
它可能如何被利用以及什么是 actua
这是正确的解决方案
7:32
第一个是签名或检查，所以可能你已经说过了
7:39
关于这一点，在之前的课程中，非常重要的是，你要验证正确的各方已经签署了一份
7:48
这里的交易是一个不正确或不安全的例子呃
7:54
代码这实际上只是一个锚上下文，称为更新用户
7:59
data um 它是同名指令的 um 上下文，所以想象一下
8:07
呃，一个用户想要更新呃链上的一些数据，呃在这里你可以看到呃
8:15
一个帐户，一个输入帐户是用户帐户，另一个是
8:20
数据帐户因此数据帐户绑定到用户，因为呃它是 PDA
8:28
嗯地址是基于一些席位嗯用户数据和用户
8:36
关键但是这里是用户帐户的嗯只有帐户信息
8:43
使用类型，这种类型实际上呃不检查任何东西，所以它是不安全的，呃
8:50
实际上任何知道用户公钥的人都可以调用这个
8:57
指导和呃是的呃他不知道呃他不需要知道
9:02
签名它的私钥，这样在这种情况下任何人基本上都可以提供呃
9:10
正确的用户帐户并更新任何的数据
9:15
用户所以正确的方法是使用锚点而不是使用帐户信息
9:21
呃将使用签名者呃实际上输入签名者类型呃
9:28
自动呃验证签名者或该用户签署了
9:34
交易，呃，因此在这种情况下，你不能提供不同的
9:40
给定数据的用户帐户 uh
9:49
帐户的下一个漏洞是呃缺少地址
9:55
检查一下，在这种情况下，您必须验证帐户是否具有预期的
10:01
地址，以便您知道呃您已经熟悉 Solana
10:08
编程模型呃所以你知道每个程序都需要呃作为输入所有
10:14
它将使用的帐户，因此它会读取或写入呃和呃，是的，也许不是大多数
10:23
但很多时候你必须验证呃提供的帐户实际上是你期望的帐户，所以
10:31
这里又是一个例子，假设你有一个包含一些结构的结构
10:37
配置数据，因此第一个是允许的管理员的公钥
10:45
修改一些数据和数据
10:52
再次，我们在这里有上下文
10:57
指令并有两个帐户，因此第一个帐户是管理员帐户
11:03
必须签署指令以确保其正确，并且另一个帐户是 PDA
11:09
帐户 uh 以及某个 um PDA uh 地址 全局地址 上的配置数据
11:17
对于你的程序来说，在这种情况下，实际上是
11:23
不安全，因为管理员帐户未绑定到配置
11:29
呃配置帐户和数据本身所以实际上在你的程序中
11:35
想要验证管理员帐户是否与以下帐户相同
11:40
保存在您的配置数据中，但这里没有完成，所以 eer 可以做什么
11:46
容易做的是提供任何类型的嗯
11:51
帐户呃作为管理员签署交易然后嗯供应呃
11:59
你的程序的配置数据，程序会
12:05
正确的方法是使用 uh 锚点
12:12
约束，所以实际上有不同的方法来实现它，但是
12:17
至少对我来说最好的就是使用 has 之一
12:23
约束在这里你可以看到呃我们这里有一个管理员所以
12:31
实际上呃这里的名字admin必须匹配呃
12:36
嗯数据结构所以你在这里有管理员
12:42
配置数据中的名称，它也必须与帐户的名称相匹配
12:48
你提供的，所以它会验证管理员帐户实际上是
12:54
与保存在您的配置中的公钥相同或具有相同的公钥
12:59
数据这样呃你不能提供不同的呃管理员
13:10
帐户然后我们有所有者检查或所有权检查嗯它有点相似所以
13:20
你必须你必须检查呃那个呃
13:25
您提供给程序的帐户由预期拥有
13:31
程序呃这是一个方案，所以你的程序在这里接收作为输入
13:38
例如，一些配置数据帐户，正如您所知，每个帐户都有
13:46
不同的字段，因此其中一个字段是持有该公钥的所有者字段
13:52
您的帐户所有者的信息，然后您就有一些数据
13:57
示例，如果我们再次使用这段代码
14:04
是呃，这是呃撤回指令的上下文，呃考虑以下
14:11
场景所以我们再次有一位管理员暂时签署了指令
14:19
出于这个呃示例的目的，我们假设呃管理员呃
14:27
已验证 直接在 uh 指令中验证 uh 所以我们这里省略了 uh
14:35
所以我们可以使用帐户信息 uh 结构或输入 uh 所以是的让我们
14:42
考虑到我们不能呃提供一个不同的呃管理员来检查它
14:48
在其他地方这是可能的呃但是由于某种原因呃我们
14:53
已决定呃使用未经检查的帐户信息呃类型进行配置
14:58
配置呃帐户，然后我们有一些呃财政帐户呃，那就是
15:04
又是一个 PDA 呃所以在这种情况下嗯 eer 可以
15:10
实际上呃创建配置帐户呃
15:15
通过他的程序，呃他基本上可以创建
15:21
与配置帐户的数据结构完全相同，因此当它被传递时呃
15:27
在你的程序中，你将能够访问管理配置。 关键呃
15:34
属性或功能以及呃检查管理员呃和
15:41
您帐户中保存的配置是相同的
15:46
通过，因此它将允许他从
15:52
财政部所以是的，这当然是不安全的，也是正确的做法
15:59
这里只是使用帐户类型，所以帐户类型实际上是
16:07
自动呃检查所有者呃所以如果你离开它嗯
16:13
就像它在右侧一样，呃，它会呃，然后锚就会
16:18
呃预计这个帐户的所有者应该是你的程序并且呃呃实际上呃它会
16:26
自动为您检查，您不必在这里做任何其他事情，嗯在某些情况下，您可能想要
16:34
呃所有者是呃一些不同的程序例如呃所以在这种情况下
16:41
你可以使用所有者呃约束但是是的嗯它实际上是
16:50
很容易做呃所有权呃检查与锚嗯嗯和呃我想要什么
16:57
这里要显示的是，在大多数情况下，如果您有一个帐户
17:04
你想呃反序列化所以一个数据帐户呃然后你无论如何都会使用
17:11
帐户 uh 输入 uh 因为那么您还必须提供 uh uh 输入 uh 或
17:17
您想要反序列化的结构呃所以不太可能
17:22
那呃你会使用帐户信息嗯嗯所以这样阿诺尔就呃相当
17:29
直观，但无论如何我想在这里向您展示所有权呃利用所以
17:38
呃，你可能知道这可能会发生，呃，也许这里还有另一句话
17:45
呃，对于财务账户，我们实际上使用了账户信息，但是嗯，除了这个事实之外
17:53
呃不是数据帐户呃这只是持有资金的地址
17:59
呃，但这也是另一个呃所有者检查嗯，这是一种内在的呃
18:05
事实上，呃，国库账户位于 PDA 地址上，如果它是一个
18:12
PDA 地址呃，您可能已经知道 PDA 地址是从某些
18:18
座位所以在这种情况下这是金库这里呃凹凸也是
18:23
你的程序的 ID 或公钥所以实际上锚定在这里呃检查呃
18:31
地址是正确的，因为呃它会为你计算和验证呃
18:37
PDA 地址在这里计算正确，所以这是另一种方法
18:43
你如何检查
18:52
所有权，因此下一个漏洞是任意的 CPI CPI 代表
19:01
对于跨程序调用，所以它与前一个有点相似，嗯，这样
19:10
呃，你必须验证我们要调用的目标程序是否具有正确的
19:16
地址所以让我们采用以下程序结构呃让我们假设
19:24
我们有一个主程序，这个主程序调用外部
19:29
程序，还需要我们输入 uh 作为用户帐户某个池的输入
19:35
帐户，也许还有一些呃系统帐户，我在这里省略了它
19:40
简单性，嗯，是的，所以你想调用的外部程序
19:47
当然有一些关键，实际上你必须这样做
19:52
验证呃但是是的，在我们之前呃我我可以向你展示如何做到这一点，嗯我
19:59
可以给你一个例子，你如何实际上利用任意
20:05
CPI 想象一下这样的场景，您的主程序对于某些人来说
20:12
Reason 调用您的外部 Pro 程序，以便将资金从
20:19
用户帐户呃到池帐户并且呃所以主程序调用
20:25
外部程序，呃，一旦外部程序成功完成
20:32
它的执行然后主程序将锁定呃那个用户例如
20:38
存入一些金额呃到池帐户，然后再次存入一些金额
20:44
因为只有外部程序才能验证呃正确性
20：50
池帐户地址，以便您如何利用
20:56
呃利用 被利用实际上是任何人呃如果你这样做
21:03
不检查外部程序的密钥，并且它是主程序应该正确的程序
21:10
执行是你可以提供一个不同的程序，实际上会采取
21:19
来自用户的签名，因此外部程序由于 um
21:26
特权嗯呃特权传播呃将是
21:32
允许从用户帐户转移乐趣资金，所以呃它将转移
21:38
资金可能会转移到其他帐户，否则它会启动不结盟
21:44
转移帐户资金 呃但是呃提供的恶意
21：50
程序实际上会呃成功完成然后你的主程序呃
21:57
不会注意到呃发生了一些不好的事情并且它会发现呃
22:04
给定的用户实际上将他的呃资金锁定在池中
22:10
帐户，所以这实际上是您不知道的事情
22:16
想要，呃，如果你使用的话，它实际上可能会再次出现在你的程序中
22:23
帐户信息 uh 类型为 um
22:29
检查过，呃，是的，正确的方法是使用锚点呃程序
22:38
输入 uh 程序类型 uh 验证 uh 中的程序
22:45
那个叫做我的程序呃的案例有正确的呃地址，就像你一样
22:53
预计呃有一点嗯评论所以并且实际上支持呃出于
23:00
盒子里只有三个程序，所以第一个程序是系统程序，如果你想的话
23:05
例如创建新帐户，然后嗯令牌和关联令牌呃
23:13
程序，所以这些是令牌呃，抱歉，使用的程序呃
23:18
很多时候，这就是为什么 um 锚点支持它们开箱即用，那么当然，呃
23:26
你可以使用 uh 到 um uh 到 uh
23:33
基本上 um 为你生成 CPI 呃模块
23:40
自动嗯，这超出了本课的范围，但是，呃，是的，这相当
23:46
很简单，所以我建议你检查呃呃交叉程序
23:52
呃呃锚点呃文档中的调用呃章节
23:59
是的，但是一旦你这样做了，那么你的嗯exter的验证呃
24:06
程序真的很简单呃你只能使用程序呃类型和
24:11
你的程序的名称，然后，Anor 再次检查
24:22
那么我们有数学和逻辑问题，所以这一章非常重要
24:30
因为在这种情况下锚实际上不能真正帮助你它可以帮助你
24:37
在某种程度上，嗯，但实际上锚对你的逻辑一无所知
24:44
关于你的程序呃所以锚只能做你告诉它做的事情呃所以
24:51
数学和逻辑问题你必须自己解决
24:58
其中之一或最常见的是嗯当然呃或者是问题
25:06
由于算术和精度问题，经常会发生这样的情况：
25:12
某种溢出或下溢，所以你应该呃总是使用或也许不总是
25:18
但在大多数情况下，您应该使用经过检查的算术运算
25:24
Rust 和呃你应该呃嗯验证你的
25:30
嗯你的计算所以是的这就是为什么也在
25:36
一开始我就告诉过你，广泛测试非常重要
25:42
你的程序因为这类问题
25:48
呃可以在测试中被有效地发现呃在呃在
25:55
在部署开始或之前，如果您有测试，那么您应该验证
26:03
帐户数据和指令参数，因此锚再次可以帮助您
26:09
例如，反序列化帐户数据，它将帮助您呃
26:15
检查呃有人没有呃提供呃例如呃呃不正确呃
26:24
帐户具有相同的呃结构呃然后rust呃可以帮助你验证
26:32
提供的 uh 参数 uh 到指令中实际上已经
26:38
正确的类型等等，但 Anor 和 rust 呃又不是
26:44
知道你想用这个数据和值做什么，所以
26:51
完全由您自己来验证提供给您的值
26:57
程序呃是正确的并且它们例如在呃正确的范围内并且
27:03
所以下一点是你
27:09
应该确保指令以正确的顺序执行，所以有时嗯它可能相当
27:20
逻辑上，例如，在投票程序的情况下
27:28
呃你想等呃
27:33
在投票真正开始之前投票所以呃让我们想象一下你有一些
27:39
开始日期呃所以你当然想收到呃之后的选票
27:45
开始日期，所以对于呃常见做法来说这是合乎逻辑的
27:51
是你在你的程序中保留某种呃内部状态嗯
27:57
你只需呃检查你的程序在某些方面处于正确的状态
28:05
情况呃可能不是那么明显呃所以可能有
28:11
是不同的呃场景呃哪里呃呃
28:16
例如，您将在一条指令中设置一些数据，该指令将被使用
28:22
在另一条指令中，在这种情况下再次如此
28:28
呃你必须呃通过测试来防止错误呃例如不同的
28:35
呃不同的顺序
28:41
说明，然后呃最后一个非常常见的问题，我呃
28:47
想跟大家分享的是大家也应该防止呃意外
28:52
当你传递重复的可变帐户时的行为实际上实际上是或者
29:00
是的，帐户不必是可变的，但是，是的，嗯

常常
29:10
呃，你想要拥有例如用户呃用户 A 和呃用户 B 并且有一些
29:16
行动呃，发生了呃，但你没有想到
29:22
如果有人为用户 A 和用户 B 提供相同的帐户的情况
29:29
嗯，所以这是你应该牢记的事情，嗯，最好的
29:35
事情是呃对呃做呃适当的测试呃但是呃是的
29:43
你可以如何预防它，例如使用锚点
29:48
约束嗯和呃你可以有这样的东西，用户有一个密钥
29:55
uh 不等于 uh 用户 b 密钥
30:00
呃这样你就可以把支票或安全检查放在呃
30:06
上下文，你不必将它与你的
30:14
该行的下一个逻辑是重新初始化和复兴索引，因此
30:21
它们有点相关，因为呃它们都与生命周期相关
30:29
呃，第一个重新初始化的帐户，嗯，就是你
30:37
实际上在大多数情况下不想重新初始化已经初始化的
30:42
帐户嗯，因为嗯，例如，新的初始化可能会重置
30:48
一些内部状态，这会给攻击者提供机会
30:54
利用你的程序 um 来防止 Anchor 中出现这种情况
31:00
呃，这很简单，所以你只需在帐户上使用 init 约束即可，呃什么
31:08
实际上锚所做的是它 um 添加 um
31:14
鉴别器 呃到一个数据帐户 鉴别器 它是 um 八个数组
31:21
数据开头的字节基本上与数据相关
31:28
呃结构呃你保存在数据帐户和呃初始化
31:35
约束 um 实际上检查判别式 uh 是否被检查
31:42
呃，抱歉是否已设置，呃，如果之前已经设置过，那么呃，它
31:50
不会重新初始化给定的帐户，那么另一种情况是
31:58
复兴攻击呃所以它是相似的呃因为你实际上不想
32:03
重复使用已经关闭的帐户，以关闭 salana 上的帐户
32:10
呃你必须将其灯端口设置为零，因此该帐户呃不会
32:18
不再免租，将被垃圾收集
32:25
运行时，但是垃圾收集实际上仅在事务之后运行
32:32
已完成，因此如果帐户未正确关闭，则网络可以
32:40
在一条指令中关闭帐户，然后直接包含一个新帐户
32:46
重新初始化呃帐户的指示或者他可以例如发送呃
32:52
新的灯端口到帐户，这样呃呃呃帐户呃不会
33:00
在 Anchor 中再次进行垃圾收集，您可以使用 close
33:07
约束，你可以或者你必须包括接收者呃帐户
33:13
将收到兰波特的租金和紧密的约束
33:21
实际上嗯重置或设置了歧视
33:28
呃到一个特定于已关闭帐户的新值，这样呃你
33:33
不能呃基本上嗯重复使用已经关闭的
33:42
帐户，然后我还包括了一些其他问题，所以我们没有呃
33:48
很多时间，所以我们无法在时间内涵盖所有可能的问题
33:54
框架呃，我们有，但是嗯，无论如何我想提及它们，以便你知道
34:00
它的存在首先是呃你应该验证帐户数据类型
34:07
避免所谓的磁带类型角色扮演呃，这意味着嗯一个 eer 可以
34:16
嗯最终呃提供一个数据呃
34:21
使用不同的数据类型，然后你的程序会将其远端化
34:27
是的，给定的数据类型不对应，是的，作为 DAT 数据
34:35
类型可能会重叠，例如，它可能仍然是序列化的呃
34:44
正确，但是呃是的，呃嗯不正确
34:50
数据呃，它可能会给他们呃利用你的程序的可能性
34:57
呃在 Anchor 呃这很简单，嗯你只能呃使用帐户类型呃
35:05
你给定的 uh 类型 uh 和 uh 然后 aner
35:10
呃检查你的数据开头的鉴别器呃以匹配呃
35:17
数据类型那么下一点是你
35:23
应该总是使用规范碰撞来避免多个有效的
35:28
pdas uh 规范凹凸意味着 uh 这是 uh 的第一个值
35:35
当你计算 PDA 呃地址时你计算的凹凸呃因为呃
35:42
PDA 地址，您可能知道，这是一个特殊的地址，被删除了
35:51
嗯曲线，呃，它没有
35:58
私钥呃但是凹凸可能有不同的呃值所以呃
36:04
有嗯是的最佳实践，只有规范，所以这意味着第一个或
36:10
最高的呃碰撞数应该是
36:15
用于避免嗯有多个有效的
36:21
pdaas 以及你如何做到这一点的方法是，嗯，是的，你基本上应该使用
36:27
以标准方式锚定，您要么将此处的凹凸留空
36:35
所以嗯锚会
为您计算并锚定每次所需时间
36:42
规范凹凸或者呃你可以，正如你在这里看到的呃你可以呃使用凹凸
36:52
您之前在初始化过程中存储过的数据，所以这里是数据。
36:57
碰撞是指实际保存在您的数据帐户中的碰撞值，但是
37:04
你永远不应该让用户任意选择
37:11
碰撞，最后一点是，呃，你不应该使用共享或全局 PDA
37:20
当局，嗯，相反，你应该使用嗯，是的，特定的或用户特定的掌上电脑，所以
37:29
在此示例中，您可以看到您有两个帐户，一个数据帐户
37:35
呃以及用户帐户和呃，正如你可以在这里看到的呃
37:40
数据帐户与用户帐户相关呃因为席位是派生的
37:49
来自用户呃公钥地址呃所以你永远不应该呃有一个
37:57
全球 PDA 帐户，赋予 uh 权限 uh to yes 处理 uh 数据
38:07
来自其他用户的当然可能有或者有一些用例但是呃嗯
38:16
一般做法是呃避免
38:24
这个和呃是的很多最后但并非最不重要的是我在这里呃给你一个
38:30
推荐资源呃，这实际上是 Solana 本身的一个教训呃
38:38
这是地址 Sol def。 应用程序课程，如果您将滚动到
38:46
页面底部有最后一个模块 7 呃关于 um 程序安全性
38:54
呃我强烈建议你去呃通过这些课程呃这是
39:00
相当广泛，有不同的呃例子，嗯也有呃不同的
39:07
嗯演示嗯它的灵感来自嗯
39:13
呃阿玛尼呃谁的例子
39:19
开发了 um 锚，所以是的，如果您有兴趣，我可以强烈推荐它
39:25
更多详细信息，这就是常见的内容
39:33
也许在最后我想做一个简短的总结
39:39
再次起来，我在这里重复了我在最开始向您展示的提示
39:46
首先，我建议您使用锚点，它内置安全性
39:53
它具有的功能嗯嗯真的嗯很好
39:59
优点呃，正如我之前解释的那样，你应该广泛地测试你的
40:06
程序呃，并让你的项目嗯审计呃，正如我之前所说，所以大家
40:15
呃犯呃错误呃和呃是的，又是呃呃通常的做法呃
40:24
审核你的呃你的项目，也许还有一些呃其他呃技巧
40:30
你应该呃避免非标准代码和库呃所以我相信
40:36
如果你愿意遵循惯例并且如果你愿意遵循
40:44
嗯锚的指导方针嗯然后你可以避免很多
40:49
错误呃是 Solana 特定的呃然后你实际上可以专注于
40:57
逻辑和测试测试你的程序的逻辑另一个提示是呃你
41:05
应该将常见漏洞列表与您的程序进行比较
41:10
定期，所以你知道这很容易
41:15
忘记某事或者经常修改程序多次
41:22
所以也许一开始你就考虑过不同的场景但是
41:29
经过一些修改后，你集成了一些
41:35
呃，有些巴克却不知道，所以我建议你经常去看看
41:42
常见漏洞列表，并将其与您的进行比较
41:48
程序，呃最后一点是我向你展示了不同的嗯
41:56
漏洞利用的可能性，但是在实践中，漏洞利用可能会经常发生
42:05
是你所遇到的多个呃问题的组合，所以它没有
42:11
成为呃只是其中之一呃但是呃因为你实际上呃有两个呃
42:20
不同的问题呃它可能会给剥削者带来可能性呃到呃
42:28
例如，用你的资金或类似的东西，作为一个单独的问题，也许呃，这并不重要，但是
42:37
嗯，你应该呃一直考虑更复杂
42:44
是的，今天就是这样，我希望你学到了一些东西
42:50
非常感谢，下次再见
```