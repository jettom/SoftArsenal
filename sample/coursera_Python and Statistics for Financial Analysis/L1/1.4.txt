After learning the basics of DataFrame, we will learn more methods which help us to create new variables. We have learned how to select a subset of data for our DataFrame. We have learned two methods; select by labels and select by position. To create new variables for other columns, we will learn a new method of DataFrame slicing, which is a special one. It is to select particular columns. For example, we want to select column of Close price. To select in such a single column from DataFrame, you can use fb ['Close']. If you want to select multiple columns for example both Open and Close prices, you can use lists of names by putting all names in a square bracket, and give this names list an entry to over 10 multiple columns. If you want to create a new column called Price1 which is Close price of tomorrow, you can do this. The fb now has a new column. What is the right side of this code? Basically,it is Close price, but with shift operator, shift(-1), we move a whole column of Close price one row upward. Then at each row or trading day, the price in the Price1 column is the Close price of tomorrow. Here's a demonstration of a shift(-1). It shifts a whole column upwards by one row. Next, we create a new variable called PriceDiff which is the price change between tomorrow and today, which is a term we will try to predict in topic four. A good thing to work with DataFrame is that we can compute them column-wisely. We do not need to compute a price difference one day by one day. Instead, we can take this job nicely with only one line of code. It is very intuitive and clean. That is why a lot of practitioners like to use Python to pre-process data. We can check the updated DataFrame fb, the new column is generated. Similarly, we can calculate the daily return. We know daily return should be PriceDiff divided by Close, as we can see from the formula. We double check if the new variable is created. Next, we will create a new variable direction. The direction is determined by PriceDiff. If PriceDiff is positive, the direction is up and denoted as one. Otherwise, it's down and denoted as negative one. We cannot use column-wise transformation of any columns to get "direction". Instead, we will use List comprehension. Here's the code for the List comprehension. It looks very complicated. Let us look into the details. Red part of code is condition. It says it will give value 1 for Direction if PriceDiff is positive. Otherwise, it is negative. The yellow part defines the domain in which this operation will be performed. ei is a name for any Index of fb. It means for any index ei, Direction will be valued according to the condition defined in the red region. List comprehension is a very important tool for creation of new variables following very complicated rules. A Moving average is a widely used signal in stock trading, which is loading average price over a defined number of days. Random fluctuations are very common in stock price. Taking an average price in a period can smooth out noise. It is sought to be good to find the trend. For example, we want to calculate the moving average of close price over three days, which is the average of Close price of today, yesterday, and the day before yesterday. Let us take a close look, what is a shift(1). Shift(1) is to shift the whole column downward by one row. Hence, at any given row or day, the shifted Close price in fact is a Close price of yesterday. What is shift(2)? It shifts the column of Close price downward by two rows, which get the Close price two days ago. We found NaN at the top which means Not a Number. Since we do not have data before December 31, we get NaN in the top two rows if we move the columns downward by two rows. If a new variable is created using shift Close price that we also has NaN values at the top two rows. Check the new update fb. Now, it had a new column which is called Average3. In Python, if some valuable data is missing, we call it is missing values. It will also show NaN value if read into DataFrame. DataFrame has very nice methods to handle NaN values. We will discuss more details in the next several topics. In DataFrame, it has building method to compute moving average over any number of days. Here, we create two new columns or variables. MA40 is a moving average Close price over 40 days, and MA200 is a moving average price over 200 days. Rolling is a very nice method to provide us rolling window calculation. We can use this rolling window to calculate mean even sum. Now, let us plot these moving averages and compare them with Close price. We first plot Close price then moving average 40. And finally, moving average 200. You can see those moving average smooth the original Close price. Moving average 40 which is colored as orange is more closely associated with Close price than moving average 200. Hence, we call moving average 40 is a fast signal and MA200 is a slow signal which reflects the price over a long history. If MA40 is above MA200, some traders who we call trend-following traders, they believe the stock price will move upwards for a while. In this video, you have learned how to create new variables such as price difference, daily return, direction, and moving average. We also discussed how to use List comprehension to create new variables following a very complicated rule. In the next video we will build a simple strategy for stock trading based on our discussion about slow and fast signals.